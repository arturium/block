## Building Blockchain in Go. Part 2: Proof-of-Work

Вступление
В предыдущей статье мы создали очень простую структуру данных, которая является сущностью базы данных блокчейна. И мы сделали возможным добавлять в него блоки с цепочечным отношением между ними: каждый блок связан с предыдущим. Увы, у нашей реализации блокчейна есть один существенный недостаток: добавление блоков в цепочку легко и дешево. Одним из ключевых элементов блокчейна и биткойна является то, что добавление новых блоков - тяжелая работа. Сегодня мы собираемся исправить этот недостаток.

### POW Доказательство-оф-работы
Ключевая идея блокчейна заключается в том, что нужно выполнить некоторую тяжелую работу, чтобы поместить в нее данные. Именно эта тяжелая работа делает блокчейн безопасным и последовательным. Также выплачивается награда за эту тяжелую работу (так люди получают монеты за майнинг).

Этот механизм очень похож на механизм реальной жизни: нужно много работать, чтобы получить награду и поддерживать свою жизнь. В блокчейне некоторые участники (майнеры) сети работают, чтобы поддерживать сеть, добавлять в нее новые блоки и получать вознаграждение за свою работу. В результате их работы блок включается в блокчейн безопасным способом, который поддерживает стабильность всей базы данных блокчейна. Стоит отметить, что тот, кто закончил работу, должен это доказать.

Весь этот механизм «делай тяжелую работу и докажи» называется доказательством работы. Это сложно, потому что требует большой вычислительной мощности: даже высокопроизводительные компьютеры не могут сделать это быстро. Более того, сложность этой работы время от времени возрастает, чтобы поддерживать скорость новых блоков около 6 блоков в час. В биткойнах цель такой работы - найти хеш для блока, который соответствует некоторым требованиям. И именно этот хеш служит доказательством. Таким образом, поиск доказательства - это реальная работа.

И последнее, что нужно отметить. Алгоритмы проверки работоспособности должны соответствовать требованию: выполнять работу сложно, но проверить доказательство легко. Доказательство обычно передается кому-то еще, поэтому для него не требуется много времени, чтобы его проверить.

## хеширования
В этом параграфе мы обсудим хеширование. Если вы знакомы с концепцией, вы можете пропустить эту часть.

***Хеширование*** - это процесс получения хеша для указанных данных. Хеш - это уникальное представление данных, по которым он был рассчитан. Хеш-функция - это функция, которая принимает данные произвольного размера и создает хеш фиксированного размера. Вот некоторые ключевые особенности хеширования:

Исходные данные не могут быть восстановлены из хеша. Таким образом, хеширование не является шифрованием.
Некоторые данные могут иметь только один хеш, и хеш уникален.
Изменение хотя бы одного байта во входных данных приведет к совершенно другому хешу.
Пример хеширования

Хеш-функции широко используются для проверки согласованности данных. Некоторые поставщики программного обеспечения публикуют контрольные суммы в дополнение к программному пакету. После загрузки файла вы можете передать его в функцию хеширования и сравнить полученный хеш с предоставленным разработчиком программного обеспечения.

В блокчейне хеширование используется для обеспечения согласованности блока. Входные данные для алгоритма хеширования содержат хэш предыдущего блока, что делает невозможным (или, по крайней мере, довольно сложным) изменение блока в цепочке: необходимо пересчитать его хэш и хэши всех блоков после него ,

## Hashcash
Биткойн использует Hashcash , алгоритм Proof-of-Work, который был изначально разработан для предотвращения спама в электронной почте. Это может быть разделено на следующие шаги:

Возьмите некоторые общеизвестные данные (в случае электронной почты это адрес электронной почты получателя; в случае Биткойна это заголовки блоков).
Добавьте счетчик к этому. Счетчик начинается с 0.
Получите хэш data + counterкомбинации.
Убедитесь, что хеш соответствует определенным требованиям.
Если это так, все готово.
Если этого не произойдет, увеличьте счетчик и повторите шаги 3 и 4.
Таким образом, это алгоритм грубой силы: вы меняете счетчик, вычисляете новый хеш, проверяете его, увеличиваете счетчик, вычисляете хеш и т. Д. Вот почему он требует больших вычислительных ресурсов.

Теперь давайте подробнее рассмотрим требования, которым должен соответствовать хеш. В оригинальной реализации Hashcash требование звучит так: «первые 20 бит хеша должны быть нулями». В биткойнах требование время от времени корректируется, потому что по своей структуре блок должен генерироваться каждые 10 минут, несмотря на то, что вычислительная мощность увеличивается со временем и все больше и больше майнеров присоединяются к сети.

Чтобы продемонстрировать этот алгоритм, я взял данные из предыдущего примера («Я люблю пончики») и нашел хеш, который начинается с 3 нулевых байтов:

Пример Hashcash

ca07ca это шестнадцатеричное значение счетчика, равное 13240266 в десятичной системе.

## Реализация
Хорошо, мы закончили с теорией, давайте напишем код! Сначала давайте определим сложность майнинга:


const targetBits = 24
В биткойнах «целевые биты» - это заголовок блока, в котором хранится сложность, с которой был добыт блок. Пока мы не будем реализовывать алгоритм корректировки цели, поэтому мы можем просто определить сложность как глобальную константу.

24 - произвольное число, наша цель состоит в том, чтобы иметь цель, которая занимает менее 256 бит в памяти. И мы хотим, чтобы разница была достаточно значительной, но не слишком большой, потому что чем больше разница, тем сложнее найти правильный хэш.

type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))

	pow := &ProofOfWork{b, target}

	return pow
}

Здесь создайте ProofOfWork структуру, которая содержит указатель на блок и указатель на цель. 
«Target» - это другое название для требования, описанного в предыдущем абзаце. 
Мы используем большое целое число из-за способа сравнения хеша с целью: 
мы преобразуем хеш в большое целое число и проверим, меньше ли оно цели.

В NewProofOfWork функции мы инициализируем a big.Intзначением 1 и сдвигаем его влево на 256 - targetBits биты. 
256 это длина хэша SHA-256 в битах, и это алгоритм хеширования SHA-256, который мы будем использовать. 
Шестнадцатеричное представление target:

```
0x10000000000000000000000000000000000000000000000000000000000
```

И это занимает 29 байтов в памяти. И вот его визуальное сравнение с хешами из предыдущих примеров:

0fac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3
0000010000000000000000000000000000000000000000000000000000000000
0000008b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca
Первый хэш (рассчитанный на «я люблю пончики») больше цели, поэтому он не является действительным доказательством работы. Второй хэш (рассчитанный на «Мне нравится donutsca07ca») меньше, чем цель, поэтому это веское доказательство.

Вы можете думать о цели как о верхней границе диапазона: если число (хеш) ниже, чем граница, это допустимо, и наоборот. Понижение границы приведет к меньшему количеству действительных чисел, и, следовательно, более трудная работа, необходимая для поиска действительного.

Теперь нам нужны данные для хеширования. Давайте подготовим это:

```golang
func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.Data,
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
```

Эта часть проста: мы просто объединяем блочные поля с целью и одноразовым номером. nonceздесь счетчик из описания Hashcash выше, это криптографический термин.

Хорошо, все приготовления завершены, давайте реализуем ядро ​​алгоритма PoW:

```golang
func (pow *ProofOfWork) Run() (int, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := 0

	fmt.Printf("Mining the block containing \"%s\"\n", pow.block.Data)
	for nonce < maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		fmt.Printf("\r%x", hash)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			break
		} else {
			nonce++
		}
	}
	fmt.Print("\n\n")

	return nonce, hash[:]
}
```

Сначала мы инициализируем переменные: hashIntэто целочисленное представление hash; nonceэто счетчик. Далее мы запускаем «бесконечный» цикл: он ограничен maxNonce, что равно math.MaxInt64; это сделано, чтобы избежать возможного переполнения nonce. Хотя сложность нашей реализации PoW слишком мала для переполнения счетчика, все же лучше иметь эту проверку, на всякий случай.

В цикле мы:

Подготовьте данные.
Хеш это с SHA-256.
Преобразуйте хеш в большое целое число.
Сравните целое число с целью.
Так легко, как это было объяснено ранее. Теперь мы можем удалить SetHashметод Blockи изменить NewBlockфункцию:

```golang
func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}, 0}
	pow := NewProofOfWork(block)
	nonce, hash := pow.Run()

	block.Hash = hash[:]
	block.Nonce = nonce

	return block
}
```

Здесь вы можете увидеть, что nonceсохраняется как Blockсобственность. Это необходимо, потому что nonceтребуется для проверки доказательства. BlockСтруктура теперь выглядит так:

```golang
type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
```

Хорошо! Давайте запустим программу, чтобы увидеть, все ли работает нормально:

```golang
Mining the block containing "Genesis Block"
00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Mining the block containing "Send 1 BTC to Ivan"
00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Mining the block containing "Send 2 more BTC to Ivan"
000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe

Prev. hash:
Data: Genesis Block
Hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Prev. hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1
Data: Send 1 BTC to Ivan
Hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Prev. hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804
Data: Send 2 more BTC to Ivan
Hash: 000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe
```

Ура! Вы можете видеть, что каждый хеш теперь начинается с трех нулевых байтов, 
и для их получения требуется некоторое время.

Осталось сделать еще одну вещь: давайте сделаем возможным подтверждение доказательств работ.

```golang
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int

	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])

	isValid := hashInt.Cmp(pow.target) == -1

	return isValid
}
```

И здесь нам нужен спасенный одноразовый номер.
Давайте проверим еще раз, что все в порядке:

```golang
func main() {
	...

	for _, block := range bc.blocks {
		...
		pow := NewProofOfWork(block)
		fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
		fmt.Println()
	}
}
```

Выход:

```golang
...

Prev. hash:
Data: Genesis Block
Hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
PoW: true

Prev. hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
Data: Send 1 BTC to Ivan
Hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
PoW: true

Prev. hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
Data: Send 2 more BTC to Ivan
Hash: 000000e42afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a
PoW: true
```

### Заключение
Наш блокчейн на шаг ближе к своей реальной архитектуре: добавление блоков теперь требует тяжелой работы, 
поэтому майнинг возможен. Но в ней по-прежнему отсутствуют некоторые важные функции: база данных 
блокчейна не является постоянной, нет кошельков, адресов, транзакций и отсутствует механизм консенсуса. 
Все эти вещи мы будем реализовывать в будущих статьях, а пока - счастливого майнинга!
