# Building Blockchain in Go. Part 5: Addresses

## Вступление
В предыдущей статье мы начали реализацию транзакций. Вы также были ознакомлены с безличным характером транзакций: нет учетных записей пользователей, ваши личные данные (например, имя, номер паспорта или SSN) не требуются и не хранятся где-либо в биткойнах. Но все же должно быть что-то, что идентифицирует вас как владельца результатов транзакции (то есть владельца монет, заблокированных на этих выходах). И это то, для чего нужны биткойн-адреса. До сих пор мы использовали произвольные пользовательские строки в качестве адресов, и пришло время реализовать реальные адреса, поскольку они реализованы в биткойнах.

Эта часть вносит существенные изменения в код, поэтому нет смысла объяснять их все здесь. Пожалуйста, обратитесь к этой странице, чтобы увидеть все изменения со времени последней статьи.

## Биткойн-адрес
Вот пример адреса биткойнов: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa, Это самый первый биткойн-адрес, который предположительно принадлежит Сатоши Накамото. Биткойн-адреса являются публичными. Если вы хотите отправить кому-то монеты, вам нужно знать их адрес. Но адреса (несмотря на то, что они уникальны) - это не то, что идентифицирует вас как владельца «кошелька». Фактически, такие адреса представляют собой удобочитаемое представление открытых ключей. В Биткойне ваша личность - это пара (или пары) закрытых и открытых ключей, хранящихся на вашем компьютере (или в другом месте, к которому у вас есть доступ). Биткойн использует комбинацию криптографических алгоритмов для создания этих ключей и гарантирует, что никто в мире не сможет получить доступ к вашим монетам без физического доступа к вашим ключам. Давайте обсудим, что это за алгоритмы.

## Криптография с открытым ключом
Алгоритмы криптографии с открытым ключом используют пары ключей: открытый ключ и закрытый ключ. Открытые ключи не являются конфиденциальными и могут быть раскрыты любому. Напротив, закрытые ключи не должны раскрываться: никто, кроме владельца, не должен иметь к ним доступ, потому что именно закрытые ключи служат идентификатором владельца. Вы - ваши личные ключи (конечно, в мире криптовалют).

По сути, биткойн-кошелек - это просто пара таких ключей. Когда вы устанавливаете приложение кошелька или используете биткойн-клиент для генерации нового адреса, для вас создается пара ключей. Тот, кто контролирует закрытый ключ, контролирует все монеты, отправленные на этот ключ в биткойнах.

Закрытый и открытый ключи - это просто случайные последовательности байтов, поэтому они не могут быть распечатаны на экране и прочитаны человеком. Вот почему Биткойн использует алгоритм для преобразования открытых ключей в удобочитаемую строку.

Если вы когда-либо пользовались приложением Биткойн-кошелька, скорее всего, для вас была сгенерирована мнемоническая пароль. Такие фразы используются вместо закрытых ключей и могут быть использованы для их генерации. Этот механизм реализован в BIP-039 .

Хорошо, теперь мы знаем, что идентифицирует пользователей в биткойнах. Но как Биткойн проверяет владение результатами транзакций (и монетами, хранящимися на них)?

## Цифровые подписи
В математике и криптографии существует концепция цифровой подписи - алгоритмы, которые гарантируют:

эти данные не были изменены при передаче от отправителя получателю;
эти данные были созданы определенным отправителем;
что отправитель не может отказать в отправке данных.
Применяя алгоритм подписи к данным (т. Е. Подписывая данные), можно получить подпись, которая впоследствии может быть проверена. Цифровая подпись происходит с использованием закрытого ключа, а проверка требует открытого ключа.

## Для подписи данных нам нужны следующие вещи:

### данные для подписи;
закрытый ключ
Операция подписи создает подпись, которая сохраняется во входных данных транзакции. Для проверки подписи необходимо следующее:

данные, которые были подписаны;
подпись;
открытый ключ.
Проще говоря, процесс проверки можно описать следующим образом: проверьте, что эта подпись была получена из этих данных с помощью закрытого ключа, используемого для генерации открытого ключа.

Цифровые подписи не являются шифрованием, вы не можете восстановить данные из подписи. Это похоже на хеширование: вы запускаете данные через алгоритм хеширования и получаете уникальное представление данных. Разница между сигнатурами и хешами состоит в том, что пары ключей: они делают возможной проверку подписи 
Но пары ключей также могут быть использованы для шифрования данных: закрытый ключ используется для шифрования, а открытый ключ используется для расшифровки данных. Биткойн не использует алгоритмы шифрования.

Каждый вход транзакции в биткойнах подписывается тем, кто создал транзакцию. Каждая транзакция в Биткойне должна быть проверена, прежде чем она будет помещена в блок. Средства проверки (помимо других процедур):

Проверка того, что входные данные имеют разрешение на использование выходных данных предыдущих транзакций.
Проверка правильности подписи транзакции.
Схематически процесс подписания данных и проверки подписи выглядит следующим образом:

https://jeiwan.cc/images/signing-scheme.png

Давайте теперь рассмотрим полный жизненный цикл транзакции:

В начале есть блок генезиса, который содержит транзакцию с монетами. Нет реальных входных данных в транзакциях с монетами, поэтому подписывать не нужно. Вывод транзакции coinbase содержит хешированный открытый ключ ( RIPEMD16(SHA256(PubKey))используются алгоритмы).
Когда кто-то отправляет монеты, создается транзакция. Входные данные транзакции будут ссылаться на выходные данные предыдущей транзакции. Каждый вход будет хранить открытый ключ (не хэшированный) и подпись всей транзакции.
Другие узлы в сети Биткойн, которые получают транзакцию, проверит ее. Помимо прочего, они проверят, что: хеш открытого ключа во входе совпадает с хешем ссылочного выхода (это гарантирует, что отправитель тратит только принадлежащие ему монеты); подпись верна (это гарантирует, что транзакция создана реальным владельцем монет).
Когда узел майнера готов добывать новый блок, он помещает транзакцию в блок и начинает ее.
Когда блокируется добыча, каждый другой узел в сети получает сообщение о том, что блок добыт, и добавляет блок в цепочку блоков.
После того, как блок добавлен в цепочку блоков, транзакция завершена, на ее выходы можно ссылаться в новых транзакциях.
Криптография с эллиптической кривой
Как описано выше, открытый и закрытый ключи являются последовательностями случайных байтов. Поскольку для идентификации владельцев монет используются закрытые ключи, существует обязательное условие: алгоритм случайности должен генерировать действительно случайные байты. Мы не хотим случайно генерировать закрытый ключ, принадлежащий кому-то другому.

Биткойн использует эллиптические кривые для генерации закрытых ключей. Эллиптические кривые - это сложная математическая концепция, которую мы не будем здесь подробно объяснять (если вам интересно, ознакомьтесь с этим кратким введением в эллиптические кривые ПРЕДУПРЕЖДЕНИЕ: математические формулы!). Нам нужно знать, что эти кривые можно использовать для генерации действительно больших и случайных чисел. Кривая, используемая биткойнами, может случайным образом выбрать число от 0 до 2 ²⁵⁶ (что составляет приблизительно 10 ⁷⁷, когда в видимой вселенной есть от 10 ⁷⁸ до 10 ⁸ 2 атомов). Такой огромный верхний предел означает, что практически невозможно создать один и тот же закрытый ключ дважды.

Кроме того, Биткойн использует (и мы будем) алгоритм ECDSA (алгоритм цифровой подписи эллиптической кривой) для подписания транзакций.

## Base58
Теперь вернемся к указанному выше адресу биткойна: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. 
Теперь мы знаем, что это удобочитаемое представление открытого ключа. И если мы расшифруем его, вот как 
выглядит открытый ключ (как последовательность байтов, записанных в шестнадцатеричной системе):
```
0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93
```

Биткойн использует алгоритм Base58 для преобразования открытых ключей в удобочитаемый формат. 
Алгоритм очень похож на известный Base64, но он использует более короткий алфавит: некоторые буквы 
были удалены из алфавита, чтобы избежать некоторых атак, использующих сходство букв. 
Таким образом, нет таких символов: 0 (ноль), O (заглавная o), I (заглавная i), l (строчная L), 
потому что они выглядят одинаково. Также нет символов + и /.


Давайте схематически представим процесс получения адреса из открытого ключа:

https://jeiwan.cc/images/address-generation-scheme.png


Таким образом, упомянутый выше декодированный открытый ключ состоит из трех частей:

```
Version  Public key hash                           Checksum
00       62E907B15CBF27D5425399EBF6F0FB50EBB88F18  C29B7D93
```

Поскольку функции хеширования являются односторонними (т. Е. Их нельзя сторнировать), 
невозможно извлечь открытый ключ из хэша. Но мы можем проверить, использовался ли открытый ключ для получения хеша, 
запустив его, думая о функциях сохранения хеша и сравнив хеш.

Хорошо, теперь, когда у нас есть все части, давайте напишем некоторый код. Некоторые концепции должны быть более понятными при написании кода.

## Реализация адресов
Начнем со Wallet структуры:
```golang

type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

type Wallets struct {
	Wallets map[string]*Wallet
}

func NewWallet() *Wallet {
	private, public := newKeyPair()
	wallet := Wallet{private, public}

	return &wallet
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256()
	private, err := ecdsa.GenerateKey(curve, rand.Reader)
	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

	return *private, pubKey
}
```

## Кошелек - это всего лишь пара ключей. Нам также понадобится Wallets тип, чтобы хранить коллекцию кошельков, 
сохранять их в файл и загружать из него. В конструкции Wallet генерируется новая пара ключей. newKeyPair 
Функция проста: ECDSA основана на эллиптических кривых, так что нам нужно одно. Затем с помощью кривой 
генерируется закрытый ключ, а из закрытого ключа генерируется открытый ключ. Следует отметить одну вещь: в
алгоритмах на основе эллиптической кривой открытые ключи - это точки на кривой. Таким образом, открытый ключ
представляет собой комбинацию координат X, Y. В биткойнах эти координаты объединяются и образуют открытый ключ.

Теперь давайте сгенерируем адрес:

```golang
func (w Wallet) GetAddress() []byte {
	pubKeyHash := HashPubKey(w.PublicKey)

	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := checksum(versionedPayload)

	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, err := RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}

func checksum(payload []byte) []byte {
	firstSHA := sha256.Sum256(payload)
	secondSHA := sha256.Sum256(firstSHA[:])

	return secondSHA[:addressChecksumLen]
}
```

## Вот шаги для преобразования открытого ключа в адрес Base58:

Возьмите открытый ключ и дважды его хешируйте с помощью RIPEMD160(SHA256(PubKey))алгоритмов хеширования.

Предварительно добавьте версию алгоритма генерации адреса к хешу.

Рассчитайте контрольную сумму, хэшируя результат шага 2 с SHA256(SHA256(payload)). 

***Контрольная сумма*** - это первые четыре байта полученного хэша.
Добавьте контрольную сумму к version+PubKeyHashкомбинации.
Кодируйте version+PubKeyHash+checksumкомбинацию с помощью Base58.

В результате вы получите настоящий биткойн-адрес , вы даже можете проверить его баланс на blockchain.info .
Но я могу заверить вас, что баланс равен 0 независимо от того, сколько раз вы генерируете новый адрес и проверяете 
его баланс. Вот почему выбор правильного алгоритма шифрования с открытым ключом так важен: учитывая, что закрытые 
ключи являются случайными числами, вероятность генерации одного и того же числа должна быть как можно ниже. 
В идеале оно должно быть как никогда.

Также обратите внимание, что вам не нужно подключаться к узлу Биткойн, чтобы получить адрес. 
Алгоритм генерации адреса использует комбинацию открытых алгоритмов, которые реализованы во многих языках 
программирования и библиотеках.

Теперь нам нужно изменить входы и выходы, чтобы они использовали адреса:

```golang
type TXInput struct {
	Txid      []byte
	Vout      int
	Signature []byte
	PubKey    []byte
}

func (in *TXInput) UsesKey(pubKeyHash []byte) bool {
	lockingHash := HashPubKey(in.PubKey)

	return bytes.Compare(lockingHash, pubKeyHash) == 0
}

type TXOutput struct {
	Value      int
	PubKeyHash []byte
}

func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0
}
```

Обратите внимание, что мы больше не используются ScriptPubKeyи ScriptSigполя, потому что мы не собираемся реализовать 
язык сценариев. Вместо этого, ScriptSigразделяется на Signatureи PubKeyполей, и ScriptPubKey переименован в PubKeyHash. 
Мы будем реализовывать ту же блокировку / разблокировку выходов и логику подписи входов, что и в биткойнах, 
но вместо этого мы будем делать это в методах.

UsesKey Метод проверяет , что входной использует специальный ключ , чтобы открыть выход. Обратите внимание, что на 
входах хранятся необработанные открытые ключи (т.е. не хэшированные), но функция принимает хэшированный. IsLockedWithKey 
проверяет, использовался ли предоставленный хэш открытого ключа для блокировки вывода. 
Это дополнительная функция UsesKey, и они оба используются FindUnspentTransactionsдля создания связей между транзакциями.

Lockпросто блокирует вывод. Когда мы отправляем кому-то монеты, мы знаем только их адрес, поэтому функция принимает 
адрес в качестве единственного аргумента. Затем адрес декодируется, и из него извлекается хэш открытого ключа и 
сохраняется в PubKeyHashполе.

Теперь давайте проверим, что все работает правильно:

```
$ blockchain_go createwallet
Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt

$ blockchain_go createwallet
Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h

$ blockchain_go createwallet
Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy

$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d
```

Done!

```
$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 10

$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 5
2017/09/12 13:08:56 ERROR: Not enough funds

$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 6
00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162

Success!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 4

$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h
Balance of '15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h': 6

$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy
Balance of '1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy': 0
```

Ницца! Теперь давайте реализуем подписи транзакций.

## Реализация подписей
Транзакции должны быть подписаны, потому что это единственный способ в Биткойне гарантировать, 
что нельзя тратить монеты, принадлежащие кому-то другому. Если подпись недействительна, транзакция также считается
недействительной и, следовательно, не может быть добавлена ​​в цепочку блоков.

У нас есть все для реализации подписи транзакций, кроме одного: данных для подписи. Какие части транзакции
фактически подписаны? Или сделка подписана целиком? Выбор данных для подписи очень важен. Дело в том, что данные
для подписи должны содержать информацию, которая уникальным образом идентифицирует данные. Например, не имеет смысла 
подписывать только выходные значения, потому что такая подпись не будет учитывать отправителя и получателя.

Учитывая, что транзакции разблокируют предыдущие выходные данные, перераспределяют их значения и блокируют новые 
выходные данные, следующие данные должны быть подписаны:

## Хеши открытых ключей хранятся в незаблокированных выходах. 
Это идентифицирует «отправителя» транзакции.

Хеши открытых ключей хранятся в новых заблокированных выходах. Это идентифицирует «получателя» транзакции.

### Значения новых выходов.
В Bitcoin, блокировка / разблокировка логика хранится в сценарии, которые хранятся в ScriptSigи ScriptPubKey 
области входов и выходов, соответственно. Поскольку биткойны допускают разные типы таких скриптов, он подписывает 
весь контент ScriptPubKey.

Как видите, нам не нужно подписывать открытые ключи, хранящиеся во входах. Из-за этого в Биткойне подписывается не
транзакция, а ее урезанная копия с сохранением входных данных ScriptPubKeyиз ссылочных выходов.

Подробный процесс получения урезанной копии транзакции описан здесь . Вероятно, он устарел, но мне не удалось найти
более надежный источник информации.

Хорошо, это выглядит сложно, поэтому давайте начнем кодировать. Начнем с Signметода:

```golang
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return
	}

	txCopy := tx.TrimmedCopy()

	for inID, vin := range txCopy.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
		signature := append(r.Bytes(), s.Bytes()...)

		tx.Vin[inID].Signature = signature
	}
}
```

Метод принимает закрытый ключ и карту предыдущих транзакций. Как упоминалось выше, чтобы подписать транзакцию, нам 
нужен доступ к выходам, на которые ссылаются входы транзакции, поэтому нам нужны транзакции, которые хранят эти выходные 
данные.

Давайте рассмотрим этот метод шаг за шагом:

```golang
if tx.IsCoinbase() {
	return
}
```

Транзакции Coinbase не подписаны, поскольку в них нет реальных входных данных.

```golang
txCopy := tx.TrimmedCopy()
```

Подрезанная копия будет подписана, а не полная транзакция:

```golang
func (tx *Transaction) TrimmedCopy() Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	for _, vin := range tx.Vin {
		inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})
	}

	for _, vout := range tx.Vout {
		outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})
	}

	txCopy := Transaction{tx.ID, inputs, outputs}

	return txCopy
}
```

Копия будет включать в себя все входы и выходы, но TXInput.Signatureи TXInput.PubKeyустановлена ​​на ноль.

Далее мы перебираем каждый вход в копии:

```golang
for inID, vin := range txCopy.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
  ```
  
В каждом входе Signatureустановлено значение nil(просто двойная проверка) и PubKey значение PubKeyHash указанного выхода. 
На данный момент, все сделки , но в настоящее время один являются «пустыми», то есть их Signatureи PubKey 
поля установлены на ноль. Таким образом, входные данные подписываются отдельно , хотя это не является необходимым 
для нашего приложения, но Биткойн позволяет транзакциям содержать входные данные, ссылающиеся на разные адреса.

```golang
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

Hash Метод сериализует транзакцию и хешей его с помощью алгоритма SHA-256.   
Полученный хэш - это данные, которые мы собираемся подписать. После получения хеша мы должны сбросить 
PubKeyполе, чтобы оно не влияло на дальнейшие итерации.

Теперь центральная часть:

```golang
	r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
	signature := append(r.Bytes(), s.Bytes()...)

	tx.Vin[inID].Signature = signature
```

Мы подписываем txCopy.IDс privKey. 
Подпись ECDSA - это пара чисел, которые мы объединяем и храним в поле ввода Signature.

Теперь функция проверки:

```golang
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inID, vin := range tx.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:(sigLen / 2)])
		s.SetBytes(vin.Signature[(sigLen / 2):])

		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:(keyLen / 2)])
		y.SetBytes(vin.PubKey[(keyLen / 2):])

		rawPubKey := ecdsa.PublicKey{curve, &x, &y}
		if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
			return false
		}
	}

	return true
}
```

Метод довольно прост. Во-первых, нам нужна та же копия транзакции:

```golang
txCopy := tx.TrimmedCopy()
```

Далее нам понадобится та же кривая, которая используется для генерации пар ключей:

```golang
curve := elliptic.P256()
```

Далее мы проверяем подпись в каждом входе:

```golang
for inID, vin := range tx.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

Эта часть идентична той, что в Signметоде, потому что во время проверки нам нужны те же данные, что были подписаны.

```golang
	r := big.Int{}
	s := big.Int{}
	sigLen := len(vin.Signature)
	r.SetBytes(vin.Signature[:(sigLen / 2)])
	s.SetBytes(vin.Signature[(sigLen / 2):])

	x := big.Int{}
	y := big.Int{}
	keyLen := len(vin.PubKey)
	x.SetBytes(vin.PubKey[:(keyLen / 2)])
	y.SetBytes(vin.PubKey[(keyLen / 2):])
```

Здесь мы распаковываем значения, хранящиеся в TXInput.Signatureи TXInput.PubKey, 
так как подпись - это пара чисел, а открытый ключ - это пара координат. Мы связали их ранее для хранения, 
и теперь нам нужно распаковать их для использования в crypto/ecdsaфункциях.

```golang
	rawPubKey := ecdsa.PublicKey{curve, &x, &y}
	if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
		return false
	}
}

return true
```

Вот оно: мы создаем ecdsa.PublicKeyоткрытый ключ, извлеченный из ввода, и выполняем ecdsa.Verify 
передачу подписи, извлеченной из ввода. Если все входные данные проверены, верните true; если хотя бы один вход 
не прошел проверку, верните false.

Теперь нам нужна функция для получения предыдущих транзакций. Поскольку это требует взаимодействия с блокчейном,
мы сделаем его методом Blockchain:

```golang
func (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {
	bci := bc.Iterator()

	for {
		block := bci.Next()

		for _, tx := range block.Transactions {
			if bytes.Compare(tx.ID, ID) == 0 {
				return *tx, nil
			}
		}

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}

	return Transaction{}, errors.New("Transaction is not found")
}

func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	tx.Sign(privKey, prevTXs)
}

func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	return tx.Verify(prevTXs)
}
```

Эти функции просты: FindTransaction находит транзакцию по идентификатору (это требует итерации по всем блокам в блокчейне); 
SignTransactionпринимает транзакцию, находит транзакции, на которые она ссылается, и подписывает ее; 
VerifyTransaction делает то же самое, но вместо этого проверяет транзакцию.

Теперь нам нужно подписать и подтвердить транзакции. Подписание происходит в NewUTXOTransaction:

```golang
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	...

	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
Проверка происходит до помещения транзакции в блок:

func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	var lastHash []byte

	for _, tx := range transactions {
		if bc.VerifyTransaction(tx) != true {
			log.Panic("ERROR: Invalid transaction")
		}
	}
	...
}
```

И это все! Давайте проверим все еще раз:

```
$ blockchain_go createwallet
Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR

$ blockchain_go createwallet
Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab

$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008

Done!

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 6
0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b

Success!

$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
Balance of '1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR': 4

$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab
Balance of '1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab': 6
```

Ничего не сломано. Потрясающие!

Давайте также закомментируем 
bc.SignTransaction(&tx, wallet.PrivateKey)вызов, NewUTXOTransactionчтобы гарантировать, 
что неподписанные транзакции не могут быть добыты:

```golang
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
   ...
	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	// bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
```

$ go install

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 1
2017/09/12 16:28:15 ERROR: Invalid transaction

### Заключение
Это действительно здорово, что мы так далеко продвинулись и реализовали так много ключевых функций Биткойна! 
Мы реализовали практически все, что находится за пределами сети, и в следующей части мы закончим транзакции.



