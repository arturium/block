# Building Blockchain in Go. Part 6: Transactions 

## Вступление
В самой первой части этой серии я говорил, что блокчейн - это распределенная база данных. 
Тогда мы решили пропустить «распределенную» часть и сосредоточиться на части «база данных».
До сих пор мы реализовали практически все, что делает базу данных блокчейном. В этом посте мы
рассмотрим некоторые механизмы, которые были пропущены в предыдущих частях, а в следующей части мы
начнем работать над распределенной природой блокчейна.

## Предыдущие части:

Основной прототип  
Доказательство-оф-работы  
Постоянство и CLI  
Транзакции 1  
Адреса  

Эта часть вносит существенные изменения в код, поэтому нет смысла объяснять их все здесь.
Пожалуйста, обратитесь к этой странице, чтобы увидеть все изменения со времени последней статьи.

## Вознаграждение
Одна крошечная вещь, которую мы пропустили в предыдущей статье, это награды за майнинг.
И у нас уже есть все для его реализации.

## Награда 
это просто денежная транзакция. Когда майнинг-узел начинает анализировать новый блок, 
он берет транзакции из очереди и добавляет к ним транзакцию в монетной базе. Единственный вывод 
монетной транзакции содержит хэш открытого ключа майнера.

Внедрить награды так же просто, как обновить sendкоманду:

```golang
func (cli *CLI) send(from, to string, amount int) {
    ...
    bc := NewBlockchain()
    UTXOSet := UTXOSet{bc}
    defer bc.db.Close()

    tx := NewUTXOTransaction(from, to, amount, &UTXOSet)
    cbTx := NewCoinbaseTX(from, "")
    txs := []*Transaction{cbTx, tx}

    newBlock := bc.MineBlock(txs)
    fmt.Println("Success!")
}
```
В нашей реализации тот, кто создает транзакцию, добывает новый блок и, таким образом, получает вознаграждение.

## Набор UTXO
В Части 3: Постоянство и CLI мы изучили, как Bitcoin Core хранит блоки в базе данных. 
Было сказано, что блоки хранятся в blocksбазе данных, а выходные данные транзакций хранятся в chainstate базе данных. 
Позвольте мне напомнить вам, какова структура chainstate:

```
'c' + 32-byte transaction hash -> unspent transaction output record for that transaction
'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs
```

После этой статьи мы уже реализовали транзакции, но мы не использовали их chainstateдля хранения результатов.
Итак, это то, что мы собираемся сделать сейчас.

chainstate не хранит транзакции. Вместо этого он хранит то, что называется набором UTXO или набором
неизрасходованных транзакций. Кроме того, он хранит «хэш блока, до которого база данных представляет
выходные данные неизрасходованных транзакций», который мы пока опускаем, потому что мы не используем высоты блоков 
(но мы реализуем их в следующих статьях).

## Итак, почему мы хотим установить UTXO?

Рассмотрим Blockchain.FindUnspentTransactions метод, который мы реализовали ранее:

```golang
func (bc *Blockchain) FindUnspentTransactions(pubKeyHash []byte) []Transaction {
    ...
    bci := bc.Iterator()

    for {
        block := bci.Next()

        for _, tx := range block.Transactions {
            ...
        }

        if len(block.PrevBlockHash) == 0 {
            break
        }
    }
    ...
}
```

Функция находит транзакции с неизрасходованными выходами. Поскольку транзакции хранятся в блоках, он перебирает каждый 
блок в цепочке блоков и проверяет каждую транзакцию в нем. По состоянию на 18 сентября 2017 года в Биткойне насчитывается 
485 860 блоков, и вся база данных занимает 140+ ГБ дискового пространства. Это означает, что для проверки транзакций 
необходимо запустить полный узел. Кроме того, проверка транзакций потребует итерации по многим блокам.

Решение проблемы состоит в том, чтобы иметь индекс, который хранит только неизрасходованные выходные данные, и именно
это делает набор UTXO: это кэш, который создается из всех транзакций блокчейна (путем итерации по блокам, да, но это 
делается только один раз ) и позже используется для расчета баланса и проверки новых транзакций. Набор UTXO составляет 
около 2,7 Гб по состоянию на сентябрь 2017 года.

Хорошо, давайте подумаем, что нам нужно изменить, чтобы реализовать набор UTXO. В настоящее время для поиска
транзакций используются следующие методы:

### Blockchain.FindUnspentTransactions - 
     основная функция, которая находит транзакции с неизрасходованными выходами. Именно эта функция выполняет 
     итерацию всех блоков.
     
### Blockchain.FindSpendableOutputs- 
    эта функция используется при создании новой транзакции. Если находит достаточное количество выходов, 
    содержащих требуемое количество. Использует Blockchain.FindUnspentTransactions.
    
### Blockchain.FindUTXO- находит неизрасходованные выходные данные для хэша открытого ключа, используемого 
    для получения баланса. Использует Blockchain.FindUnspentTransactions.
    
### Blockchain.FindTransaction- находит транзакцию в блокчейне по его идентификатору. Он перебирает все блоки, 
пока не найдет его.

Как видите, все методы перебирают блоки в базе данных. Но пока мы не можем улучшить их все, потому что набор 
UTXO хранит не все транзакции, а только те, которые имеют неизрасходованные выходные данные. 
Таким образом, он не может быть использован в Blockchain.FindTransaction.

## Итак, мы хотим следующие методы:

***Blockchain.FindUTXO*** - находит все неизрасходованные выходные данные, перебирая блоки.
UTXOSet.Reindex- использует FindUTXOдля поиска неизрасходованных выходов и сохраняет их в базе данных. 

Вот где происходит кэширование.
***UTXOSet.FindSpendableOutputs***- аналог Blockchain.FindSpendableOutputs, но использует набор UTXO.
***UTXOSet.FindUTXO***- аналог Blockchain.FindUTXO, но использует набор UTXO.
***Blockchain.FindTransaction*** остается такой же.

Таким образом, две наиболее часто используемые функции теперь будут использовать кеш! Давайте начнем кодирование.

```golang
type UTXOSet struct {
    Blockchain *Blockchain
}
```

Мы будем использовать одну базу данных, но мы будем хранить набор UTXO в другом сегменте. Таким образом, UTXOSetв сочетании с Blockchain.

```golang
func (u UTXOSet) Reindex() {
    db := u.Blockchain.db
    bucketName := []byte(utxoBucket)

    err := db.Update(func(tx *bolt.Tx) error {
        err := tx.DeleteBucket(bucketName)
        _, err = tx.CreateBucket(bucketName)
    })

    UTXO := u.Blockchain.FindUTXO()

    err = db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket(bucketName)

        for txID, outs := range UTXO {
            key, err := hex.DecodeString(txID)
            err = b.Put(key, outs.Serialize())
        }
    })
}
```

Этот метод изначально создает набор UTXO. Сначала он удаляет корзину, если она существует, 
затем получает все неизрасходованные выходные данные из цепочки блоков и, наконец, сохраняет эти записи в корзину.

Blockchain.FindUTXOпочти идентичен Blockchain.FindUnspentTransactions, но теперь он возвращает карту 
TransactionID → TransactionOutputsпар.

Теперь набор UTXO можно использовать для отправки монет:

```golang
func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) {
    unspentOutputs := make(map[string][]int)
    accumulated := 0
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            txID := hex.EncodeToString(k)
            outs := DeserializeOutputs(v)

            for outIdx, out := range outs.Outputs {
                if out.IsLockedWithKey(pubkeyHash) && accumulated < amount {
                    accumulated += out.Value
                    unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)
                }
            }
        }
    })

    return accumulated, unspentOutputs
}
```

Или проверьте баланс:

```golang
func (u UTXOSet) FindUTXO(pubKeyHash []byte) []TXOutput {
    var UTXOs []TXOutput
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            outs := DeserializeOutputs(v)

            for _, out := range outs.Outputs {
                if out.IsLockedWithKey(pubKeyHash) {
                    UTXOs = append(UTXOs, out)
                }
            }
        }

        return nil
    })

    return UTXOs
}
```

Это слегка модифицированные версии соответствующих Blockchainметодов. Эти Blockchainметоды больше не нужны.

Наличие набора UTXO означает, что наши данные (транзакции) теперь разделены на хранилища: 
фактические транзакции хранятся в блокчейне, а неизрасходованные выходные данные сохраняются в наборе UTXO. 
Такое разделение требует надежного механизма синхронизации, потому что мы хотим, чтобы набор UTXO всегда обновлялся 
и сохранял результаты самых последних транзакций. Но мы не хотим переиндексировать каждый раз, когда добывается новый 
блок, потому что мы хотим избежать этих частых сканирований блокчейна. Таким образом, нам нужен механизм обновления
набора UTXO:

```golang
func (u UTXOSet) Update(block *Block) {
    db := u.Blockchain.db

    err := db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))

        for _, tx := range block.Transactions {
            if tx.IsCoinbase() == false {
                for _, vin := range tx.Vin {
                    updatedOuts := TXOutputs{}
                    outsBytes := b.Get(vin.Txid)
                    outs := DeserializeOutputs(outsBytes)

                    for outIdx, out := range outs.Outputs {
                        if outIdx != vin.Vout {
                            updatedOuts.Outputs = append(updatedOuts.Outputs, out)
                        }
                    }

                    if len(updatedOuts.Outputs) == 0 {
                        err := b.Delete(vin.Txid)
                    } else {
                        err := b.Put(vin.Txid, updatedOuts.Serialize())
                    }

                }
            }

            newOutputs := TXOutputs{}
            for _, out := range tx.Vout {
                newOutputs.Outputs = append(newOutputs.Outputs, out)
            }

            err := b.Put(tx.ID, newOutputs.Serialize())
        }
    })
}
```

Метод выглядит масштабно, но то, что он делает, довольно просто. Когда новый блок добывается, 
набор UTXO должен быть обновлен. Обновление означает удаление израсходованных выходных данных и добавление 
неизрасходованных выходных данных из вновь добытых транзакций. Если транзакция, выходы которой были удалены, 
не содержит больше выходов, она также удаляется. Достаточно просто!

Давайте теперь используем набор UTXO там, где это необходимо:

```golang
func (cli *CLI) createBlockchain(address string) {
    ...
    bc := CreateBlockchain(address)
    defer bc.db.Close()

    UTXOSet := UTXOSet{bc}
    UTXOSet.Reindex()
    ...
}
```

Переиндексация происходит сразу после создания новой цепочки блоков. На данный момент это единственное место, 
где Reindexиспользуется, хотя здесь это выглядит чрезмерно, потому что в начале блокчейна есть только один блок
с одной транзакцией, и его Updateможно было бы использовать вместо этого. Но нам может понадобиться механизм 
переиндексации в будущем.

```golang
func (cli *CLI) send(from, to string, amount int) {
    ...
    newBlock := bc.MineBlock(txs)
    UTXOSet.Update(newBlock)
}
```

И набор UTXO обновляется после разработки нового блока.

Давайте проверим, что это работает

```
$ blockchain_go createblockchain -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
00000086a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73

Done!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5 -amount 6
0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b

Success!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL -amount 4
000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433

Success!

$ blockchain_go getbalance -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
Balance of '1F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif': 20

$ blockchain_go getbalance -address 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5
Balance of '1XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx': 6

$ blockchain_go getbalance -address 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL
Balance of '13UASQpCR8Nr41PojH8Bz4K6cmTCqweskL': 4
```

Ницца! 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1Адрес получают в награду 3 раза:

### Однажды для добычи блоков генезиса.

```
Один раз за майнинг блока 0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b.
И один раз для майнинга блока 000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433.

## Меркл Три

Есть еще один механизм оптимизации, который я хотел бы обсудить в этом посте.

Как было сказано выше, полная база данных Биткойн (то есть блокчейн) занимает более 140 ГБ дискового пространства. 
Из-за децентрализованной природы биткойнов каждый узел в сети должен быть независимым и самодостаточным, 
то есть каждый узел должен хранить полную копию блокчейна. Со многими людьми, начинающими использовать Биткойн, 
этому правилу становится все труднее следовать: маловероятно, что у всех будет полный узел. Также, поскольку узлы 
являются полноправными участниками сети, у них есть обязанности: они должны проверять транзакции и блокировать. 
Кроме того, для взаимодействия с другими узлами и загрузки новых блоков требуется определенный интернет-трафик.

В оригинальной биткойн-газете, опубликованной Сатоши Накамото, было решение этой проблемы: упрощенная проверка 
платежей (SPV). SPV - это легкий биткойн-узел, который не загружает весь блокчейн и не проверяет блоки и транзакции . 
Вместо этого он находит транзакции в блоках (для проверки платежей) и привязывается к полному узлу для получения
только необходимых данных. Этот механизм позволяет иметь несколько узлов легкого кошелька с использованием всего одного
полного узла.

Чтобы SPV был возможен, должен быть способ проверить, содержит ли блок определенную транзакцию, не загружая весь блок. 
И тут Меркле дерево вступает в игру.

Деревья Меркле используются биткойнами для получения хеша транзакций, который затем сохраняется в заголовках блоков 
и рассматривается системой проверки работоспособности. До сих пор мы просто объединяли хэши каждой транзакции в блоке
и применяли SHA-256к ним. Это также хороший способ получить уникальное представление блочных транзакций, но он не имеет 
преимуществ деревьев Меркле.

Давайте посмотрим на дерево Меркле:

Диаграмма дерева Меркле

Дерево Меркле строится для каждого блока и начинается с листьев (нижняя часть дерева), где лист - это хеш транзакции 
(биткойны используют двойное SHA256хеширование). Количество листьев должно быть четным, но не каждый блок содержит четное 
количество транзакций. В случае нечетного количества транзакций последняя транзакция дублируется (в дереве Меркле, а не 
в блоке!).

Двигаясь снизу вверх, листья группируются в пары, их хеши объединяются, и из конкатенированных хешей получается новый хеш. 
Новые хэши образуют новые узлы дерева. Этот процесс повторяется до тех пор, пока не останется только один узел, который
называется корнем дерева. Корневой хэш затем используется как уникальное представление транзакций, сохраняется в заголовках
блоков и используется в системе проверки работоспособности.

Преимущество деревьев Merkle состоит в том, что узел может проверять членство в определенной транзакции, не загружая весь
блок. Для этого требуются только хэш транзакции, корень дерева Merkle и путь Merkle.

Наконец, давайте напишем код:

```golang
type MerkleTree struct {
    RootNode *MerkleNode
}

type MerkleNode struct {
    Left  *MerkleNode
    Right *MerkleNode
    Data  []byte
}
```

Начнем со структур. Каждый MerkleNodeхранит данные и ссылки на свои ветки. 
MerkleTree на самом деле корневой узел связан со следующими узлами, которые, в свою очередь, связаны 
с другими узлами и т. д.

Давайте сначала создадим новый узел:

```golang
func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
    mNode := MerkleNode{}

    if left == nil && right == nil {
        hash := sha256.Sum256(data)
        mNode.Data = hash[:]
    } else {
        prevHashes := append(left.Data, right.Data...)
        hash := sha256.Sum256(prevHashes)
        mNode.Data = hash[:]
    }

    mNode.Left = left
    mNode.Right = right

    return &mNode
}
```

Каждый узел содержит некоторые данные. Когда узел является листом, данные передаются извне 
(в нашем случае это сериализованная транзакция). Когда узел связан с другими узлами, он берет их данные, объединяет 
и хэширует их.

```golang
func NewMerkleTree(data [][]byte) *MerkleTree {
    var nodes []MerkleNode

    if len(data)%2 != 0 {
        data = append(data, data[len(data)-1])
    }

    for _, datum := range data {
        node := NewMerkleNode(nil, nil, datum)
        nodes = append(nodes, *node)
    }

    for i := 0; i < len(data)/2; i++ {
        var newLevel []MerkleNode

        for j := 0; j < len(nodes); j += 2 {
            node := NewMerkleNode(&nodes[j], &nodes[j+1], nil)
            newLevel = append(newLevel, *node)
        }

        nodes = newLevel
    }

    mTree := MerkleTree{&nodes[0]}

    return &mTree
}
```

Когда создается новое дерево, первое, что нужно убедиться, это четное количество листьев. После этого data(который
представляет собой массив сериализованных транзакций) преобразуется в листья дерева, и из этих листьев вырастает дерево.

Теперь давайте изменим Block.HashTransactions, который используется в системе проверки работоспособности для получения
хеша транзакций:

```golang
func (b *Block) HashTransactions() []byte {
    var transactions [][]byte

    for _, tx := range b.Transactions {
        transactions = append(transactions, tx.Serialize())
    }
    mTree := NewMerkleTree(transactions)

    return mTree.RootNode.Data
}
```

Сначала транзакции сериализуются (используются encoding/gob), а затем они используются для построения дерева Меркле. 
Корень дерева будет служить уникальным идентификатором транзакций блока.

## P2PKH
Есть еще одна вещь, которую я хотел бы обсудить более подробно.

Как вы помните, в Биткойне есть язык программирования Script , который используется для блокировки выходов транзакций; 
и входы транзакции предоставляют данные для разблокировки выходов. Язык прост, и код на этом языке -
это просто последовательность данных и операторов. Рассмотрим этот пример:

## 5 2 OP_ADD 7 OP_EQUAL
5, 2И представляют 7собой данные. OP_ADDи OP_EQUALявляются операторами. Код скрипта выполняется слева направо: 
каждый фрагмент данных помещается в стек, а следующий оператор применяется к элементам верхнего стека. Сценарий 
стек «s только простой FILO (первый вход Последний выхода) для хранения памяти: первый элемент в стеке является последним ,
которое будет принято, с каждым дополнительным элементом оказываются на предыдущем.

## Давайте разберем выполнение вышеописанного скрипта на этапы:

```     
Стек: пусто. Сценарий: 5 2 OP_ADD 7 OP_EQUAL.
Стек: 5. Сценарий: 2 OP_ADD 7 OP_EQUAL.
Стек: 5 2. Сценарий: OP_ADD 7 OP_EQUAL.
Стек: 7. Сценарий: 7 OP_EQUAL.
Стек: 7 7. Сценарий: OP_EQUAL.
Стек: true. Скрипт: пустой.
``` 

OP_ADDберет два элемента из стека, суммирует их и помещает сумму в стек. OP_EQUAL 
берет два элемента из стека и сравнивает их: если они равны, он выталкивается trueв стек;
в противном случае это толкает false. Результатом выполнения скрипта является значение элемента верхнего стека:
в нашем случае это trueозначает, что скрипт завершился успешно.

Теперь давайте посмотрим на скрипт, который используется в биткойнах для совершения платежей:

```
<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

Этот скрипт называется Pay to Public Key Hash (P2PKH), и это наиболее часто используемый скрипт в биткойнах. 
Он буквально платит хешу с открытым ключом, т.е. блокирует монеты определенным открытым ключом. В этом суть 
биткойн-платежей : между ними нет счетов и средств; есть только скрипт, который проверяет правильность подписи и 
открытого ключа.

### Сценарий на самом деле хранится в двух частях:

Первый кусок,, <signature> <pubKey>хранится в ScriptSigполе ввода .
Вторая часть OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIGхранится в выходных данных ScriptPubKey.
Таким образом, его выходы определяют логику разблокировки, а входы предоставляют данные для разблокировки выходов. 
Давайте выполним скрипт:

```
Стек: пустой 
сценарий:<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature>
Скрипт:<pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature> <pubKey>
Скрипт:OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature> <pubKey> <pubKey>
Скрипт:OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature> <pubKey> <pubKeyHash>
Скрипт:<pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature> <pubKey> <pubKeyHash> <pubKeyHash>
Скрипт:OP_EQUALVERIFY OP_CHECKSIG

Стек: <signature> <pubKey>
Скрипт:OP_CHECKSIG

Стек: trueили false. Скрипт: пустой.
```

OP_DUPдублирует верхний элемент стека. OP_HASH160берет верхний элемент стека и хэширует его RIPEMD160; 
результат отбрасывается обратно в стек. OP_EQUALVERIFYсравнивает два элемента верхнего стека и, если они не равны, 
прерывает скрипт. OP_CHECKSIGпроверяет подпись транзакции, хешируя транзакцию и используя <signature>и <pubKey>. 
Последний оператор довольно сложен: он создает урезанную копию транзакции, хэширует ее (потому что это хэш транзакции, 
которая подписана) и проверяет правильность подписи, используя предоставленные <signature>и <pubKey>.

Наличие такого языка сценариев позволяет Биткойну быть платформой смарт-контрактов: этот язык делает возможными и другие 
схемы платежей, помимо перевода на один ключ. Например,

## Заключение
И это все! Мы реализовали практически все ключевые функции криптовалюты на основе цепочки блоков. У нас есть блокчейн, 
адреса, майнинг и транзакции. Но есть еще одна вещь, которая дает жизнь всем этим механизмам и делает Биткойн глобальной 
системой: консенсус. В следующей статье мы начнем реализацию «децентрализованной» части блокчейна. Оставайтесь в курсе!



