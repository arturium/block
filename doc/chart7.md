# Building Blockchain in Go. Part 7: Network

## Вступление
Пока что мы создали блокчейн, который имеет все ключевые функции: анонимные, безопасные и случайно 
сгенерированные адреса; блокчейн хранение данных; Система Proof-of-Work; надежный способ хранения транзакций.
Хотя эти функции имеют решающее значение, этого недостаточно. Что делает эти функции действительно блестящими 
и что делает возможным использование криптовалют, так это сеть. Какая польза от такой реализации блокчейна, 
работающей только на одном компьютере? Какая польза от этих функций на основе криптографии, когда есть только
один пользователь? Это сеть, которая заставляет все эти механизмы работать и быть полезной.

Вы можете думать об этих функциях блокчейна как о правилах, похожих на правила, которые люди устанавливают,
когда они хотят жить и процветать вместе. Своего рода социальные мероприятия. Сеть Blockchain - это сообщество
программ, которые следуют тем же правилам, и именно это следует правилам, которые оживляют сеть. Точно так же, 
когда люди разделяют одинаковые идеи, они становятся сильнее и могут вместе построить лучшую жизнь. Если есть 

люди, которые следуют другому набору правил, они будут жить в отдельном обществе (государстве, коммуне и т. Д.).
Аналогично, если есть узлы блокчейна, которые следуют другим правилам, они образуют отдельную сеть.

Это очень важно: без сети и без большинства узлов, использующих одинаковые правила, эти правила бесполезны!

ОТКАЗ ОТ ОТВЕТСТВЕННОСТИ: К сожалению, у меня не было достаточно времени для реализации реального прототипа сети P2P.
В этой статье я продемонстрирую наиболее распространенный сценарий, который включает в себя узлы разных типов. 
Улучшение этого сценария и превращение его в P2P-сеть может быть хорошим испытанием для вас! Также я не могу 
гарантировать, что другие сценарии, кроме того, который реализован в этой статье, будут работать. Сожалею!

Эта часть вносит существенные изменения в код, поэтому нет смысла объяснять их все здесь. Пожалуйста, обратитесь
к этой странице, чтобы увидеть все изменения со времени последней статьи.

Блокчейн Сеть
Сеть блокчейнов децентрализована, что означает, что не существует серверов, которые делают вещи, и клиентов,
которые используют серверы для получения или обработки данных. В сети блокчейн есть узлы, и каждый узел является
полноценным участником сети. Узел - это все: и клиент, и сервер. Это очень важно иметь в виду, потому что оно 
сильно отличается от обычных веб-приложений.

Сеть Blockchain - это сеть P2P (Peer-to-Peer), что означает, что узлы подключены напрямую друг к другу.
Его топология плоская, поскольку в ролях узлов нет иерархии. Вот его схематическое изображение:

Схема сети P2P ( Бизнес вектор, созданный Dooder - Freepik.com )

Узлы в такой сети сложнее реализовать, потому что они должны выполнять много операций. Каждый узел должен 
взаимодействовать с несколькими другими узлами, он должен запрашивать состояние другого узла, сравнивать 
его со своим собственным состоянием и обновлять его состояние, когда он устарел.

Роли узлов
Несмотря на то, что узлы цепочки блоков являются полноценными, они могут играть разные роли в сети. Вот они:

Miner. 
Такие узлы работают на мощном или специализированном оборудовании (например, ASIC), и их единственная цель - 
добывать новые блоки как можно быстрее. Майнеры возможны только в блокчейнах, которые используют Proof-of-Work,
потому что майнинг на самом деле означает решение головоломок PoW. Например, в блокчейнах Proof-of-Stake нет майнинга.
Полный узел. 
Эти узлы проверяют блоки, добытые майнерами, и проверяют транзакции. Для этого у них должна быть полная копия блокчейна.
Кроме того, такие узлы выполняют такие операции маршрутизации, как помощь другим узлам в обнаружении друг друга. 
Для сети очень важно иметь много полных узлов, потому что именно эти узлы принимают решения: они решают, является ли блок 
или транзакция допустимой.
SPV. 
SPV означает упрощенное подтверждение платежа. Эти узлы не хранят полную копию цепочки блоков, но они по-прежнему способны
проверять транзакции (не все, а подмножество, например, те, которые были отправлены на определенный адрес).
Узел SPV зависит от полного узла для получения данных, и может быть много узлов SPV, подключенных к одному полному узлу.
SPV делает возможными приложения для кошельков: не нужно загружать полный блокчейн, но все же можно проверять их транзакции.
Упрощение сети
Чтобы реализовать сеть в нашей цепочке блоков, мы должны упростить некоторые вещи. Проблема в том, что у нас не так
много компьютеров для симуляции сети с несколькими узлами. Мы могли бы использовать виртуальные машины или Docker 
для решения этой проблемы, но это могло бы усложнить все: вам пришлось бы решать возможные проблемы с виртуальной 
машиной или Docker, в то время как моя цель - сконцентрироваться только на реализации блокчейна. Итак, мы хотим 
запустить несколько узлов блокчейна на одной машине, и в то же время мы хотим, чтобы они имели разные адреса. 
Для этого мы будем использовать порты в качестве идентификаторов узлов , а не IP-адреса. Например, будут узлы с
адресами: 127.0.0.1:3000, 127.0.0.1:3001, 127.0.0.1:3002и т.д. Мы будем называть идентификатор порта узла и 
использованияNODE_IDпеременная окружения, чтобы установить их. Таким образом, вы можете открыть несколько окон 
терминала, установить разные NODE_IDs и запустить разные узлы.

Этот подход также требует наличия разных блокчейнов и файлов кошелька. Теперь они должны зависеть от идентификатора 
узла и называться как blockchain_3000.db, blockchain_30001.dbи wallet_3000.db, wallet_30001.dbи т. Д.

## Реализация
Итак, что происходит, когда вы загружаете, скажем, Bitcoin Core и запускаете его впервые? Он должен подключиться к 
некоторому узлу, чтобы загрузить последнее состояние блокчейна. Учитывая, что ваш компьютер не знает всех или некоторых
биткойн-узлов, что это за узел?

Жесткое кодирование адреса узла в Bitcoin Core было бы ошибкой: узел может быть атакован или отключен, что может 
привести к тому, что новые узлы не смогут подключиться к сети. Вместо этого в Bitcoin Core есть жестко закодированные 
семена DNS . Это не узлы, а DNS-серверы, которые знают адреса некоторых узлов. Когда вы запускаете чистое Биткойн-ядро,
оно подключается к одному из начальных значений и получает список полных узлов, которые затем загружают блокчейн.

В нашей реализации будет централизация. У нас будет три узла:

Центральный узел. Это узел, к которому будут подключаться все другие узлы, и это узел, который будет передавать данные 
между другими узлами.
Шахтерский узел. Этот узел будет хранить новые транзакции в mempool, и когда будет достаточно транзакций, он будет
майнить новый блок.
Кошелек-узел. Этот узел будет использоваться для отправки монет между кошельками. В отличие от узлов SPV, он будет 
хранить полную копию цепочки блоков.
Сценарий
Целью данной статьи является реализация следующего сценария:

## Центральный узел создает блокчейн.
Другой (кошелек) узел подключается к нему и скачивает блокчейн. 
Еще один (майнерский) узел подключается к центральному узлу и загружает блокчейн.
Узел кошелька создает транзакцию.
Узлы майнера получают транзакцию и хранят ее в своем пуле памяти.
Когда в пуле памяти достаточно транзакций, майнер начинает майнинг нового блока.
Когда новый блок добывается, он отправляется на центральный узел.
Узел кошелька синхронизируется с центральным узлом.
Пользователь узла кошелька проверяет, что их оплата прошла успешно.
Вот как это выглядит в биткойнах. Несмотря на то, что мы не собираемся строить настоящую P2P-сеть, мы собираемся реализовать реальный, а также основной и самый важный вариант использования биткойнов.

версия
Узлы общаются посредством сообщений. Когда запускается новый узел, он получает несколько узлов из начального числа DNS и отправляет им versionсообщение, которое в нашей реализации будет выглядеть так:

```golang
type version struct {
    Version    int
    BestHeight int
    AddrFrom   string
}
```
У нас есть только одна версия блокчейна, поэтому Versionполе не будет содержать никакой важной информации. 
BestHeightхранит длину блокчейна узла. AddFromхранит адрес отправителя.

Что должен делать узел, который получает versionсообщение? Он ответит своим собственным versionсообщением. Это своего рода рукопожатие: никакое другое взаимодействие невозможно без предварительного приветствия друг друга. Но это не просто вежливость: versionиспользуется для поиска более длинного блокчейна. Когда узел получает versionсообщение, он проверяет, больше ли блокчейн узла, чем значение BestHeight. Если это не так, узел будет запрашивать и загружать отсутствующие блоки.

Для получения сообщения нам нужен сервер:

```golang
var nodeAddress string
var knownNodes = []string{"localhost:3000"}

func StartServer(nodeID, minerAddress string) {
    nodeAddress = fmt.Sprintf("localhost:%s", nodeID)
    miningAddress = minerAddress
    ln, err := net.Listen(protocol, nodeAddress)
    defer ln.Close()

    bc := NewBlockchain(nodeID)

    if nodeAddress != knownNodes[0] {
        sendVersion(knownNodes[0], bc)
    }

    for {
        conn, err := ln.Accept()
        go handleConnection(conn, bc)
    }
}
```
Во-первых, мы жестко закодируем адрес центрального узла: каждый узел должен знать, к чему подключаться изначально. minerAddressАргумент указывает адрес для получения вознаграждений за майнинг. Этот кусок:

```golang
if nodeAddress != knownNodes[0] {
    sendVersion(knownNodes[0], bc)
}
```
Означает, что если текущий узел не является центральным, он должен отправить versionсообщение центральному узлу, чтобы выяснить, не устарела ли его цепочка блоков.

```golang
func sendVersion(addr string, bc *Blockchain) {
    bestHeight := bc.GetBestHeight()
    payload := gobEncode(version{nodeVersion, bestHeight, nodeAddress})

    request := append(commandToBytes("version"), payload...)

    sendData(addr, request)
}
```

Наши сообщения на нижнем уровне представляют собой последовательности байтов. 
Первые 12 байтов задают имя команды (в данном случае «version»), а последние байты будут содержать gob структуру 
сообщения с кодированием. commandToBytesвыглядит так:

```golang
func commandToBytes(command string) []byte {
    var bytes [commandLength]byte

    for i, c := range command {
        bytes[i] = byte(c)
    }

    return bytes[:]
}
```

Он создает 12-байтовый буфер и заполняет его именем команды, оставляя остальные байты пустыми. 
Есть противоположная функция:

```golang
func bytesToCommand(bytes []byte) string {
    var command []byte

    for _, b := range bytes {
        if b != 0x0 {
            command = append(command, b)
        }
    }

    return fmt.Sprintf("%s", command)
}
```
Когда узел получает команду, он запускает bytesToCommandдля извлечения имени команды и обрабатывает тело команды с
правильным обработчиком:

```golang
func handleConnection(conn net.Conn, bc *Blockchain) {
    request, err := ioutil.ReadAll(conn)
    command := bytesToCommand(request[:commandLength])
    fmt.Printf("Received %s command\n", command)

    switch command {
    ...
    case "version":
        handleVersion(request, bc)
    default:
        fmt.Println("Unknown command!")
    }

    conn.Close()
}
```

Хорошо, вот как versionвыглядит обработчик команд:

```golang
func handleVersion(request []byte, bc *Blockchain) {
    var buff bytes.Buffer
    var payload verzion

    buff.Write(request[commandLength:])
    dec := gob.NewDecoder(&buff)
    err := dec.Decode(&payload)

    myBestHeight := bc.GetBestHeight()
    foreignerBestHeight := payload.BestHeight

    if myBestHeight < foreignerBestHeight {
        sendGetBlocks(payload.AddrFrom)
    } else if myBestHeight > foreignerBestHeight {
        sendVersion(payload.AddrFrom, bc)
    }

    if !nodeIsKnown(payload.AddrFrom) {
        knownNodes = append(knownNodes, payload.AddrFrom)
    }
}
```

Сначала нам нужно декодировать запрос и извлечь полезную нагрузку. Это похоже на все обработчики,
поэтому я опущу этот фрагмент в будущих фрагментах кода.

Затем узел сравнивает его BestHeightс сообщением. Если блокчейн узла длиннее, он ответит versionсообщением; 
в противном случае он отправит getblocksсообщение.

getblocks
```golang
type getblocks struct {
    AddrFrom string
}
```
getblocks означает «покажи мне, какие у тебя блоки» (в биткойнах это более сложно). 
Обратите внимание, он не говорит «дай мне все свои блоки», вместо этого он запрашивает список хэшей блоков. 
Это сделано для снижения нагрузки на сеть, поскольку блоки можно загружать с разных узлов, и мы не хотим загружать 
десятки гигабайт с одного узла.

Обрабатывать команду так же просто, как:

```golang
func handleGetBlocks(request []byte, bc *Blockchain) {
    ...
    blocks := bc.GetBlockHashes()
    sendInv(payload.AddrFrom, "block", blocks)
}
```

В нашей упрощенной реализации он вернет все хэши блоков .

фактура

```golang
type inv struct {
    AddrFrom string
    Type     string
    Items    [][]byte
}
```

Биткойн использует, invчтобы показать другим узлам, какие блоки или транзакции имеет текущий узел.
Опять же, он не содержит целых блоков и транзакций, только их хэши. TypeПоле говорит , являются ли эти блоки или сделки.

Обработка inv сложнее:

```golang
func handleInv(request []byte, bc *Blockchain) {
    ...
    fmt.Printf("Recevied inventory with %d %s\n", len(payload.Items), payload.Type)

    if payload.Type == "block" {
        blocksInTransit = payload.Items

        blockHash := payload.Items[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        newInTransit := [][]byte{}
        for _, b := range blocksInTransit {
            if bytes.Compare(b, blockHash) != 0 {
                newInTransit = append(newInTransit, b)
            }
        }
        blocksInTransit = newInTransit
    }

    if payload.Type == "tx" {
        txID := payload.Items[0]

        if mempool[hex.EncodeToString(txID)].ID == nil {
            sendGetData(payload.AddrFrom, "tx", txID)
        }
    }
}
```

Если хэши блоков передаются, мы хотим сохранить их в blocksInTransitпеременной для отслеживания загруженных блоков. 
Это позволяет нам загружать блоки из разных узлов. Сразу после перевода блоков в транзитное состояние мы отправляем 
getdata команду отправителю invсообщения и обновляем blocksInTransit. В реальной P2P-сети нам бы хотелось передавать 
блоки с разных узлов.

В нашей реализации мы никогда не отправим invс несколькими хэшами. Вот почему, когда payload.Type == "tx" 
берется только первый хеш. Затем мы проверяем, есть ли у нас хэш в нашем mempool, и если нет, getdataсообщение отправляется.

получить данные

```golang
type getdata struct {
    AddrFrom string
    Type     string
    ID       []byte
}
```

getdata это запрос для определенного блока или транзакции, и он может содержать только один идентификатор блока / транзакции.

```golang
func handleGetData(request []byte, bc *Blockchain) {
    ...
    if payload.Type == "block" {
        block, err := bc.GetBlock([]byte(payload.ID))

        sendBlock(payload.AddrFrom, &block)
    }

    if payload.Type == "tx" {
        txID := hex.EncodeToString(payload.ID)
        tx := mempool[txID]

        sendTx(payload.AddrFrom, &tx)
    }
}
```

Обработчик прост: если они запрашивают блок, возвращают блок; если они запрашивают транзакцию, верните транзакцию. 
Обратите внимание, что мы не проверяем, есть ли у нас этот блок или транзакция. Это недостаток :)

блок и тх

```golang
type block struct {
    AddrFrom string
    Block    []byte
}

type tx struct {
    AddFrom     string
    Transaction []byte
}
```

Именно эти сообщения фактически передают данные.

Обработка block сообщения проста:

```golang
func handleBlock(request []byte, bc *Blockchain) {
    ...

    blockData := payload.Block
    block := DeserializeBlock(blockData)

    fmt.Println("Recevied a new block!")
    bc.AddBlock(block)

    fmt.Printf("Added block %x\n", block.Hash)

    if len(blocksInTransit) > 0 {
        blockHash := blocksInTransit[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        blocksInTransit = blocksInTransit[1:]
    } else {
        UTXOSet := UTXOSet{bc}
        UTXOSet.Reindex()
    }
}
```

Когда мы получили новый блок, мы поместили его в нашу цепочку блоков. Если есть еще блоки для загрузки, 
мы запрашиваем их с того же узла, который мы загрузили в предыдущем блоке. Когда мы наконец загрузили все блоки, 
набор UTXO переиндексируется.

TODO: Вместо того, чтобы доверять безоговорочно, мы должны проверять каждый входящий блок перед добавлением его в 
цепочку блоков.

TODO: вместо запуска UTXOSet.Reindex () следует использовать UTXOSet.Update (block), потому что если blockchain большой,
потребуется много времени для переиндексации всего набора UTXO.

Обработка txсообщений - самая сложная часть:

```golang
func handleTx(request []byte, bc *Blockchain) {
    ...
    txData := payload.Transaction
    tx := DeserializeTransaction(txData)
    mempool[hex.EncodeToString(tx.ID)] = tx

    if nodeAddress == knownNodes[0] {
        for _, node := range knownNodes {
            if node != nodeAddress && node != payload.AddFrom {
                sendInv(node, "tx", [][]byte{tx.ID})
            }
        }
    } else {
        if len(mempool) >= 2 && len(miningAddress) > 0 {
        MineTransactions:
            var txs []*Transaction

            for id := range mempool {
                tx := mempool[id]
                if bc.VerifyTransaction(&tx) {
                    txs = append(txs, &tx)
                }
            }

            if len(txs) == 0 {
                fmt.Println("All transactions are invalid! Waiting for new ones...")
                return
            }

            cbTx := NewCoinbaseTX(miningAddress, "")
            txs = append(txs, cbTx)

            newBlock := bc.MineBlock(txs)
            UTXOSet := UTXOSet{bc}
            UTXOSet.Reindex()

            fmt.Println("New block is mined!")

            for _, tx := range txs {
                txID := hex.EncodeToString(tx.ID)
                delete(mempool, txID)
            }

            for _, node := range knownNodes {
                if node != nodeAddress {
                    sendInv(node, "block", [][]byte{newBlock.Hash})
                }
            }

            if len(mempool) > 0 {
                goto MineTransactions
            }
        }
    }
}
```

Первое, что нужно сделать, это поместить новую транзакцию в mempool (опять же, транзакции должны быть проверены перед 
помещением в mempool). Следующая часть:

```golang
if nodeAddress == knownNodes[0] {
    for _, node := range knownNodes {
        if node != nodeAddress && node != payload.AddFrom {
            sendInv(node, "tx", [][]byte{tx.ID})
        }
    }
}
```

Проверяет, является ли текущий узел центральным. В нашей реализации центральный узел не будет майнить блоки. 
Вместо этого он перенаправит новые транзакции на другие узлы в сети.

Следующая большая часть предназначена только для майнерских узлов. Давайте разделим это на более мелкие части:

if len(mempool) >= 2 && len(miningAddress) > 0 {
miningAddressустанавливается только на майнерских узлах. 
Когда в mempool текущего (майнерского) узла находятся 2 или более транзакций, начинается майнинг.

```golang
for id := range mempool {
    tx := mempool[id]
    if bc.VerifyTransaction(&tx) {
        txs = append(txs, &tx)
    }
}

if len(txs) == 0 {
    fmt.Println("All transactions are invalid! Waiting for new ones...")
    return
}
```

Во-первых, все транзакции в mempool проверяются. Недопустимые транзакции игнорируются, и если нет допустимых 
транзакций, майнинг прерывается.

```golang
cbTx := NewCoinbaseTX(miningAddress, "")
txs = append(txs, cbTx)

newBlock := bc.MineBlock(txs)
UTXOSet := UTXOSet{bc}
UTXOSet.Reindex()

fmt.Println("New block is mined!")
```

Проверенные транзакции помещаются в блок, а также транзакции в виде монет с вознаграждением. 
После майнинга блока набор UTXO переиндексируется.

TODO: Опять же, UTXOSet.Update должен использоваться вместо UTXOSet.Reindex

```golang
for _, tx := range txs {
    txID := hex.EncodeToString(tx.ID)
    delete(mempool, txID)
}

for _, node := range knownNodes {
    if node != nodeAddress {
        sendInv(node, "block", [][]byte{newBlock.Hash})
    }
}

if len(mempool) > 0 {
    goto MineTransactions
}
```

После завершения транзакции она удаляется из mempool. Все остальные узлы, о которых знает текущий узел, получают 
invсообщение с хешем нового блока. Они могут запросить блок после обработки сообщения.

### Результат
Давайте сыграем сценарий, который мы определили ранее.

Сначала установите NODE_IDзначение 3000 ( export NODE_ID=3000) в первом окне терминала. Я буду использовать значки, как NODE 3000или NODE 3001перед следующими параграфами, чтобы вы знали, на каком узле выполнять действия.

NODE 3000
Создайте кошелек и новый блокчейн:

```
$ blockchain_go createblockchain -address CENTREAL_NODE
```

(Я буду использовать поддельные адреса для ясности и краткости)

После этого блокчейн будет содержать один блок генезиса. Нам нужно сохранить блок и использовать его в других узлах.
Блоки Genesis служат идентификаторами блокчейнов (в Биткойн-ядре блок Genesis жестко закодирован).

````
$ cp blockchain_3000.db blockchain_genesis.db 
NODE 3001
```

Затем откройте новое окно терминала и установите идентификатор узла в 3001. Это будет узел кошелька. 
Сформировать несколько адресов с blockchain_go createwallet, мы будем называть эти адреса WALLET_1, WALLET_2, WALLET_3.

NODE 3000
Отправьте несколько монет на адреса кошелька:

```
$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount 10 -mine
$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount 10 -mine
```

-mineфлаг означает, что блок будет немедленно добыт тем же узлом. У нас должен быть этот флаг, потому что
изначально в сети нет майнерских узлов. 

Запустите узел:

```
$ blockchain_go startnode
```

Узел должен работать до конца сценария.

NODE 3001
Запустите блокчейн узла с сохраненным выше блоком генезиса:

```
$ cp blockchain_genesis.db blockchain_3001.db
```

Запустите узел:
```
$ blockchain_go startnode
```

Он загрузит все блоки с центрального узла. Чтобы убедиться, что все в порядке, остановите узел и проверьте баланс:
```
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 10

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 10
```

Кроме того, вы можете проверить баланс CENTRAL_NODEадреса, потому что у узла 3001 теперь есть блокчейн:

```
$ blockchain_go getbalance -address CENTRAL_NODE
Balance of 'CENTRAL_NODE': 10
NODE 3002
```

Откройте новое окно терминала и установите его ID на 3002, и сгенерируйте кошелек. Это будет майнерский узел. Инициализировать блокчейн:

```
$ cp blockchain_genesis.db blockchain_3002.db
```

И запустить узел:
```
$ blockchain_go startnode -miner MINER_WALLET
NODE 3001
```
Отправить несколько монет:
```
$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount 1
$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount 1
NODE 3002
```
Быстро! Переключитесь на майнерский узел и увидите, что он добывает новый блок! Также проверьте выход центрального узла.

NODE 3001
Переключитесь на узел кошелька и запустите его:

```
$ blockchain_go startnode
```
Это загрузит недавно добытый блок!

Остановите это и проверьте баланс:

```
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 9

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 9

$ blockchain_go getbalance -address WALLET_3
Balance of 'WALLET_3': 1

$ blockchain_go getbalance -address WALLET_4
Balance of 'WALLET_4': 1

$ blockchain_go getbalance -address MINER_WALLET
Balance of 'MINER_WALLET': 10
```

Это оно!

## Заключение
Это была последняя часть серии. Я мог бы опубликовать еще несколько постов, реализующих реальный прототип P2P-сети, 
но у меня просто нет на это времени. Я надеюсь, что эта статья ответит на некоторые ваши вопросы о технологии Биткойн и
поднимет новые, на которые вы сможете найти ответы самостоятельно. В технологии Биткойн скрыто больше интересных вещей!
Удачи!

PS Вы можете начать улучшать сеть с реализации addrсообщения, как описано в сетевом протоколе Биткойн (ссылка ниже). 
Это очень важное сообщение, потому что оно позволяет узлам обнаруживать друг друга. Я начал реализовывать это, но еще 
не закончил!

